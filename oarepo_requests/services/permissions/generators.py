#
# Copyright (C) 2024 CESNET z.s.p.o.
#
# oarepo-requests is free software; you can redistribute it and/or
# modify it under the terms of the MIT License; see LICENSE file for more
# details.
#
"""Permission generators."""

from __future__ import annotations

from typing import TYPE_CHECKING, Any, override

from flask_principal import Identity, Need
from invenio_records_permissions.generators import ConditionalGenerator, Generator
from invenio_records_resources.references.entity_resolvers import EntityProxy
from invenio_requests.resolvers.registry import ResolverRegistry
from invenio_search.engine import dsl
from oarepo_runtime.datastreams.utils import get_record_service_for_record
from oarepo_workflows import WorkflowPermission
from oarepo_workflows.errors import InvalidWorkflowError, MissingWorkflowError
from oarepo_workflows.proxies import current_oarepo_workflows
from oarepo_workflows.requests import RecipientGeneratorMixin
from sqlalchemy.exc import NoResultFound

from oarepo_requests.errors import MissingTopicError
from oarepo_requests.services.permissions.identity import request_active

if TYPE_CHECKING:
    from invenio_records_resources.records import Record
    from invenio_requests.customizations.event_types import EventType
    from invenio_requests.customizations.request_types import RequestType
    from invenio_requests.records import Request
    from opensearch_dsl.query import Query

    from oarepo_requests.typing import EntityReference


class RequestActive(Generator):
    """A generator that requires that a request is being handled.

    This is useful for example when a caller identity should have greater permissions
    when calling an action from within a request.
    """

    def needs(self, **context: Any) -> list[Need]:
        """Return the needs required for the action."""
        return [request_active]

    def query_filter(self, identity: Identity = None, **context: Any) -> Query:
        """Return the query filter for the action."""
        return dsl.Q("match_none")


class IfRequestType(ConditionalGenerator):
    """Conditional generator that generates needs when a current request is of a given type."""

    def __init__(
        self, request_types: list[str] | tuple[str] | str, then_: list[Generator]
    ) -> None:
        """Initialize the generator."""
        super().__init__(then_, else_=[])
        if not isinstance(request_types, (list, tuple)):
            request_types = [request_types]
        self.request_types = request_types

    def _condition(self, request_type: RequestType, **kwargs: Any) -> bool:
        return request_type.type_id in self.request_types


# TODO: what is this for? The condition has nothing to do about event?
class IfEventOnRequestType(IfRequestType):
    """Not sure what this is for as it seems not to be used at all."""

    def _condition(self, request: Request, **kwargs: Any) -> bool:
        return request.type.type_id in self.request_types


class IfEventType(ConditionalGenerator):
    """Conditional generator that generates needs when a current event is of a given type."""

    def __init__(
        self,
        event_types: list[str] | tuple[str] | str,
        then_: list[Generator],
        else_: list[Generator] | None = None,
    ) -> None:
        """Initialize the generator."""
        else_ = [] if else_ is None else else_
        super().__init__(then_, else_=else_)
        if not isinstance(event_types, (list, tuple)):
            event_types = [event_types]
        self.event_types = event_types

    def _condition(self, event_type: EventType, **kwargs: Any) -> bool:
        return event_type.type_id in self.event_types


class RequestPolicyWorkflowCreators(WorkflowPermission):
    """Base class that generates creators from a workflow request."""

    def _getter(self, **kwargs: Any) -> Any:
        """Return an entity from the workflow."""
        raise NotImplementedError()

    def _kwargs_parser(self, **kwargs: Any) -> dict[str, Any]:
        """Transform the kwargs for subsequent methods."""
        return kwargs

    # return empty needs on MissingTopicError
    # match None in query filter
    # excludes empty needs
    def needs(self, **context: Any) -> list[Need]:
        """Return the needs generated by the workflow permission."""
        try:
            context = self._kwargs_parser(**context)
            workflow_request = self._getter(**context)
            return workflow_request.needs(**context)
        except (MissingWorkflowError, InvalidWorkflowError, MissingTopicError):
            return []

    def excludes(self, **context: Any) -> list[Need]:
        """Return the needs excluded by the workflow permission."""
        try:
            context = self._kwargs_parser(**context)
            workflow_request = self._getter(**context)
            return workflow_request.excludes(**context)
        except (MissingWorkflowError, InvalidWorkflowError, MissingTopicError):
            return []

    # not tested
    def query_filter(
        self, record: Record = None, request_type: RequestType = None, **context: Any
    ) -> Query:
        """Return the query filter generated by the workflow permission."""
        try:
            workflow_request = current_oarepo_workflows.get_workflow(record).requests()[
                request_type.type_id
            ]
            return workflow_request.query_filters(
                request_type=request_type, record=record, **context
            )
        except (MissingWorkflowError, InvalidWorkflowError, MissingTopicError):
            return dsl.Q("match_none")


class RequestCreatorsFromWorkflow(RequestPolicyWorkflowCreators):
    """Generates creators from a workflow request to be used in the request 'create' permission."""

    @override
    def _getter(self, **kwargs: Any) -> Any:
        request_type = kwargs["request_type"]
        if "record" not in kwargs:
            raise MissingTopicError(
                "Topic not found in request permissions generator arguments, can't get workflow."
            )
        record = kwargs["record"]
        return current_oarepo_workflows.get_workflow(record).requests()[
            request_type.type_id
        ]


class EventCreatorsFromWorkflow(RequestPolicyWorkflowCreators):
    """Generates creators from a workflow request to be used in the event 'create' permission."""

    @override
    def _kwargs_parser(self, **kwargs: Any) -> dict[str, Any]:
        try:
            record = kwargs[
                "request"
            ].topic.resolve()  # publish tries to resolve deleted draft
        except Exception as e:  # noqa              TODO: better exception catching here
            raise MissingTopicError(
                "Topic not found in request event permissions generator arguments, can't get workflow."
            ) from e
        kwargs["record"] = record
        return kwargs

    @override
    def _getter(self, **kwargs: Any) -> Any:
        if "record" not in kwargs:
            return None
        event_type = kwargs["event_type"]
        request = kwargs["request"]
        record = kwargs["record"]
        return (
            current_oarepo_workflows.get_workflow(record)
            .requests()[request.type.type_id]
            .allowed_events[event_type.type_id]
        )


class IfRequestedBy(RecipientGeneratorMixin, ConditionalGenerator):
    """Conditional generator that generates needs when a request is made by a given requester role."""

    def __init__(
        self,
        requesters: list[Generator] | tuple[Generator] | Generator,
        then_: list[Generator],
        else_: list[Generator],
    ) -> None:
        """Initialize the generator."""
        super().__init__(then_, else_)
        if not isinstance(requesters, (list, tuple)):
            requesters = [requesters]
        self.requesters = requesters

    @override
    def _condition(
        self,
        *,
        request_type: RequestType,
        creator: Identity | EntityProxy | Any,
        **kwargs: Any,
    ) -> bool:
        """Condition to choose generators set."""
        # get needs
        if isinstance(creator, Identity):
            needs = creator.provides
        else:
            if not isinstance(creator, EntityProxy):
                creator = ResolverRegistry.reference_entity(creator)
            needs = creator.get_needs()

        for condition in self.requesters:
            condition_needs = set(
                condition.needs(request_type=request_type, creator=creator, **kwargs)
            )
            condition_excludes = set(
                condition.excludes(request_type=request_type, creator=creator, **kwargs)
            )

            if not condition_needs.intersection(needs):
                continue
            if condition_excludes and condition_excludes.intersection(needs):
                continue
            return True
        return False

    @override
    def reference_receivers(
        self,
        record: Record | None = None,
        request_type: RequestType | None = None,
        **context: Any,
    ) -> list[EntityReference]:  # pragma: no cover
        ret = []
        for gen in self._generators(
            record=record, request_type=request_type, **context
        ):
            if isinstance(gen, RecipientGeneratorMixin):
                ret.extend(
                    gen.reference_receivers(
                        record=record, request_type=request_type, **context
                    )
                )
        return ret

    @override
    def query_filter(self, **context: Any) -> Query:
        """Search filters."""
        raise NotImplementedError(
            "Please use IfRequestedBy only in recipients, not elsewhere."
        )


class IfNoNewVersionDraft(ConditionalGenerator):
    """Generator that checks if the record has no new version draft."""

    def __init__(
        self, then_: list[Generator], else_: list[Generator] | None = None
    ) -> None:
        """Initialize the generator."""
        else_ = [] if else_ is None else else_
        super().__init__(then_, else_=else_)

    def _condition(self, record: Record, **kwargs: Any) -> bool:
        if hasattr(record, "is_draft"):
            is_draft = record.is_draft
        else:
            return False
        if hasattr(record, "versions"):
            next_draft_id = record.versions.next_draft_id
        else:
            return False
        return not is_draft and not next_draft_id


class IfNoEditDraft(ConditionalGenerator):
    """Generator that checks if the record has no edit draft."""

    def __init__(
        self, then_: list[Generator], else_: list[Generator] | None = None
    ) -> None:
        """Initialize the generator."""
        else_ = [] if else_ is None else else_
        super().__init__(then_, else_=else_)

    def _condition(self, record: Record, **kwargs: Any) -> bool:
        if getattr(record, "is_draft", False):
            return False
        records_service = get_record_service_for_record(record)
        try:
            records_service.config.draft_cls.pid.resolve(
                record["id"]
            )  # by edit - has the same id as parent record
            # i'm not sure what open unpublished means
            return False
        except NoResultFound:
            return True
